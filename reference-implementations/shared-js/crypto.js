import {ucrmErrors} from "./ucrmErrorCodes.js";


let UcrmError;
let canonicalize;
let sha3;
let jose;

export function init(ucrmError,canonicalizeFunction,sha,joseLib) {
  UcrmError = ucrmError;
  canonicalize = canonicalizeFunction;
  sha3 = sha;
  jose = joseLib;
}

export const includedPropertiesForEnvelope=["source","destinations","payload"]
export const includedPropertiesForKTRecord=["id","type","systemName","operatorName","operatorShortName","supportedApps","techSupport","key","transmitsUnsignedMessages"]

export function getSigningHash(envelope){
  return getHash(envelope,includedPropertiesForEnvelope);
}

function getHash(obj, propertyNamesToInclude){
  //to get the canonical message representation, the optional fields might have been generated by the UCRM need to be removed (together with the signature itself)
  const objClone={}
  for (const includedPropertyName of propertyNamesToInclude){
    objClone[includedPropertyName]=obj[includedPropertyName];
  }
  const canonicalString=JSON.stringify(canonicalize(objClone));
  const hash=sha3.sha3_256(canonicalString);
  return hash;
}

export async function sign(payload,privateKey){
  const jws = await new jose.CompactSign(
    new TextEncoder().encode(payload),
  )
    .setProtectedHeader({
      "typ": "UCRI_PLAIN",
      "alg": "RS256"
    })
    .sign(privateKey);

  // console.log(jws);
  return jws;
}

export async function getEnvelopeSignature(obj,privateKey){
  return getObjectSignature(obj,includedPropertiesForEnvelope,privateKey);
}

export async function getKTRecordSignature(obj,privateKey){
  return getObjectSignature(obj,includedPropertiesForKTRecord,privateKey);
}

export async function getObjectSignature(obj,propertyNamesToIgnore,privateKey){
  const hash=getHash(obj,propertyNamesToIgnore);
  return await sign(hash,privateKey);
}

export async function verifyEnvelope(obj,jws,publicKey){
  return verifyObject(obj,includedPropertiesForEnvelope,jws,publicKey);
}

export async function verifyKTRecord(obj,publicKey){
  return verifyObject(obj,includedPropertiesForKTRecord,obj.signature,publicKey);
}

async function verifyObject(obj,propertyNamesToIgnore,jws,publicKey){
  const objHash=getHash(obj,propertyNamesToIgnore);
  let verifiedData;
  try{
    verifiedData=await verifySignature(jws,publicKey);
  }catch (err){
    console.error(err.message);
    switch (err.code){
      case "ERR_JWS_INVALID":
      case "ERR_JWS_SIGNATURE_VERIFICATION_FAILED":
        throw new UcrmError(400, `Signature verification failed - reason: ${err.message}`, ucrmErrors.REQUEST_WRONG_SIGNATURE);
      default:
        //something else went wrong
        throw new UcrmError(500, `Unknown error during signature verification: message '${err.message}'`, ucrmErrors.REQUEST_INTERNAL_ERROR);
    }
  }
  if (verifiedData && verifiedData.payload!==objHash){
    let msg = `Signature was valid, but signed Object hash '${verifiedData.payload}' does not match object hash '${objHash}'`;
    console.error(msg);
    throw new UcrmError(400, msg, ucrmErrors.REQUEST_WRONG_SIGNATURE);
  }
}

export async function verifySignature(jws,publicKey){
  const { payload, protectedHeader } = await jose.compactVerify(jws, publicKey);
  // console.log(protectedHeader);
  let decodedPayload = new TextDecoder().decode(payload);
  // console.log(decodedPayload);
  return {payload:decodedPayload, protectedHeader};
}

